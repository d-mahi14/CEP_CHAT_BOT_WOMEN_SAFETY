// =====================================================
// SOS ROUTES - Node.js Backend
// =====================================================
// Modules: 4 (SOS Button), 5 (Location), 11 (Intent),
//          12 (Panic Mode), 13 (Helplines), 14 (Auto Message),
//          26 (Notifications)
// =====================================================

const express = require('express');
const router = express.Router();
const { supabase } = require('../config/supabase');
const { authenticateUser } = require('../middleware/auth');
const { decrypt } = require('../middleware/encryption');

// =====================================================
// INTENT DETECTION + RISK SCORING (Module 11, 19)
// Rule-based classifier â€” upgrade to Claude API later
// =====================================================

const EMERGENCY_KEYWORDS = {
  violence:     { keywords: ['attack', 'hit', 'beat', 'weapon', 'knife', 'gun', 'shoot', 'stab', 'assault', 'threatened', 'rob', 'kidnap', 'murder', 'kill'], score: 9 },
  medical:      { keywords: ['heart attack', 'unconscious', 'bleeding', 'chest pain', 'not breathing', 'seizure', 'overdose', 'allergic', 'stroke', 'fainted', 'injured'], score: 8 },
  fire:         { keywords: ['fire', 'burning', 'smoke', 'explosion', 'gas leak', 'flames'], score: 8 },
  harassment:   { keywords: ['following', 'stalking', 'harassed', 'molested', 'touched', 'unsafe', 'scared', 'help me', 'danger'], score: 7 },
  accident:     { keywords: ['accident', 'crash', 'fell', 'hit by', 'vehicle', 'collision', 'road', 'trapped'], score: 7 },
  mental_health:{ keywords: ['suicide', 'self harm', 'want to die', 'end my life', 'depressed', 'hopeless'], score: 8 },
};

/**
 * Classify emergency type and compute risk score from description
 */
function classifyEmergency(description = '', triggerType = 'manual') {
  const text = description.toLowerCase();
  let detectedType = 'other';
  let maxScore = triggerType === 'panic' ? 9 : 5; // panic mode starts high

  for (const [type, data] of Object.entries(EMERGENCY_KEYWORDS)) {
    const matched = data.keywords.some(kw => text.includes(kw));
    if (matched && data.score > maxScore) {
      maxScore = data.score;
      detectedType = type;
    }
  }

  return {
    emergency_type: detectedType,
    risk_score: Math.min(maxScore, 10),
    panic_mode: maxScore >= 9 || triggerType === 'panic',
  };
}

/**
 * Build auto alert message (Module 14)
 */
function buildAutoMessage(userName, emergencyType, address, riskScore) {
  const time = new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' });
  const urgency = riskScore >= 8 ? 'ðŸš¨ URGENT' : 'âš ï¸ ALERT';
  return `${urgency} - Safety App Emergency Alert

User: ${userName}
Emergency: ${emergencyType?.toUpperCase() || 'UNSPECIFIED'}
Risk Level: ${riskScore}/10
Location: ${address || 'Location being fetched...'}
Time: ${time}

Please respond immediately. This message was auto-generated by Safety App.`;
}

// =====================================================
// ROUTE: TRIGGER SOS (Module 4, 12)
// POST /api/sos/trigger
// =====================================================
router.post('/trigger', authenticateUser, async (req, res) => {
  try {
    const {
      trigger_type = 'manual',  // manual | voice | panic
      description = '',
      latitude,
      longitude,
      accuracy,
      address,
      city,
      state,
    } = req.body;

    // Classify intent + compute risk score
    const classification = classifyEmergency(description, trigger_type);

    // Get user's full name for auto-message
    const { data: userData } = await supabase
      .from('users')
      .select('full_name')
      .eq('user_id', req.userId)
      .single();

    const userName = userData?.full_name || 'Unknown User';
    const autoMessage = buildAutoMessage(
      userName,
      classification.emergency_type,
      address || (latitude ? `${latitude}, ${longitude}` : null),
      classification.risk_score
    );

    // Create the SOS incident
    const { data: incident, error: incidentError } = await supabase
      .from('sos_incidents')
      .insert([{
        user_id: req.userId,
        status: 'triggered',
        trigger_type,
        description,
        emergency_type: classification.emergency_type,
        risk_score: classification.risk_score,
        panic_mode: classification.panic_mode,
        auto_message: autoMessage,
      }])
      .select()
      .single();

    if (incidentError) throw incidentError;

    // Store initial location if provided
    if (latitude && longitude) {
      await supabase.from('sos_locations').insert([{
        incident_id: incident.id,
        user_id: req.userId,
        latitude,
        longitude,
        accuracy: accuracy || null,
        address: address || null,
        city: city || null,
        state: state || null,
        is_initial: true,
      }]);
    }

    // Notify emergency contacts (async â€” don't block response)
    notifyEmergencyContacts(req.userId, incident, autoMessage, address)
      .catch(err => console.error('Contact notification error:', err));

    // Audit log
    await supabase.from('audit_logs').insert([{
      user_id: req.userId,
      action: 'sos_triggered',
      resource_type: 'sos_incident',
      resource_id: incident.id,
      metadata: {
        trigger_type,
        emergency_type: classification.emergency_type,
        risk_score: classification.risk_score,
        panic_mode: classification.panic_mode,
      }
    }]);

    return res.status(201).json({
      success: true,
      message: 'SOS triggered successfully',
      data: {
        incident_id: incident.id,
        status: incident.status,
        risk_score: classification.risk_score,
        emergency_type: classification.emergency_type,
        panic_mode: classification.panic_mode,
        auto_message: autoMessage,
      }
    });

  } catch (error) {
    console.error('SOS trigger error:', error);
    return res.status(500).json({ success: false, error: 'Failed to trigger SOS' });
  }
});

// =====================================================
// ROUTE: UPDATE LOCATION (Module 5)
// POST /api/sos/:incidentId/location
// =====================================================
router.post('/:incidentId/location', authenticateUser, async (req, res) => {
  try {
    const { incidentId } = req.params;
    const { latitude, longitude, accuracy, altitude, speed, heading, address, city, state } = req.body;

    if (!latitude || !longitude) {
      return res.status(400).json({ success: false, error: 'latitude and longitude are required' });
    }

    // Verify incident belongs to user and is active
    const { data: incident } = await supabase
      .from('sos_incidents')
      .select('id, status')
      .eq('id', incidentId)
      .eq('user_id', req.userId)
      .single();

    if (!incident) return res.status(404).json({ success: false, error: 'Incident not found' });
    if (['resolved', 'cancelled'].includes(incident.status)) {
      return res.status(400).json({ success: false, error: 'Incident is already closed' });
    }

    // Update status to active on first location update
    if (incident.status === 'triggered') {
      await supabase.from('sos_incidents').update({ status: 'active' }).eq('id', incidentId);
    }

    const { data: loc } = await supabase.from('sos_locations').insert([{
      incident_id: incidentId,
      user_id: req.userId,
      latitude,
      longitude,
      accuracy: accuracy || null,
      altitude: altitude || null,
      speed: speed || null,
      heading: heading || null,
      address: address || null,
      city: city || null,
      state: state || null,
      is_initial: false,
    }]).select().single();

    return res.status(200).json({
      success: true,
      message: 'Location updated',
      data: { location_id: loc.id }
    });

  } catch (error) {
    console.error('Location update error:', error);
    return res.status(500).json({ success: false, error: 'Failed to update location' });
  }
});

// =====================================================
// ROUTE: RESOLVE / CANCEL SOS
// PATCH /api/sos/:incidentId/resolve
// =====================================================
router.patch('/:incidentId/resolve', authenticateUser, async (req, res) => {
  try {
    const { incidentId } = req.params;
    const { action = 'resolved', notes = '' } = req.body; // resolved | cancelled | false_alarm

    if (!['resolved', 'cancelled', 'false_alarm'].includes(action)) {
      return res.status(400).json({ success: false, error: 'Invalid action' });
    }

    const { data: incident } = await supabase
      .from('sos_incidents')
      .select('id, status')
      .eq('id', incidentId)
      .eq('user_id', req.userId)
      .single();

    if (!incident) return res.status(404).json({ success: false, error: 'Incident not found' });

    const { data: updated } = await supabase
      .from('sos_incidents')
      .update({
        status: action,
        resolved_at: new Date().toISOString(),
        resolved_by: 'user',
        resolution_notes: notes,
      })
      .eq('id', incidentId)
      .select()
      .single();

    await supabase.from('audit_logs').insert([{
      user_id: req.userId,
      action: `sos_${action}`,
      resource_type: 'sos_incident',
      resource_id: incidentId,
      metadata: { notes }
    }]);

    return res.status(200).json({
      success: true,
      message: `SOS ${action} successfully`,
      data: { incident: updated }
    });

  } catch (error) {
    console.error('SOS resolve error:', error);
    return res.status(500).json({ success: false, error: 'Failed to resolve SOS' });
  }
});

// =====================================================
// ROUTE: ACTIVE SOS (check if user has live incident)
// GET /api/sos/active
// =====================================================
router.get('/active', authenticateUser, async (req, res) => {
  try {
    const { data: incident } = await supabase
      .from('sos_incidents')
      .select('*')
      .eq('user_id', req.userId)
      .in('status', ['triggered', 'active'])
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    if (!incident) {
      return res.status(200).json({ success: true, data: { active_incident: null } });
    }

    // Get latest location
    const { data: latestLoc } = await supabase
      .from('sos_locations')
      .select('latitude, longitude, address, created_at')
      .eq('incident_id', incident.id)
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle();

    return res.status(200).json({
      success: true,
      data: {
        active_incident: {
          ...incident,
          latest_location: latestLoc || null,
        }
      }
    });

  } catch (error) {
    console.error('Get active SOS error:', error);
    return res.status(500).json({ success: false, error: 'Failed to get active SOS' });
  }
});

// =====================================================
// ROUTE: HELP HISTORY (Module 9)
// GET /api/sos/history
// =====================================================
router.get('/history', authenticateUser, async (req, res) => {
  try {
    const { page = 1, limit = 10 } = req.query;
    const offset = (page - 1) * limit;

    const { data: history, error, count } = await supabase
      .from('help_history')
      .select('*', { count: 'exact' })
      .eq('user_id', req.userId)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) throw error;

    return res.status(200).json({
      success: true,
      data: {
        history,
        pagination: { page: Number(page), limit: Number(limit), total: count }
      }
    });

  } catch (error) {
    console.error('Help history error:', error);
    return res.status(500).json({ success: false, error: 'Failed to get help history' });
  }
});

// =====================================================
// ROUTE: GET HELPLINES (Module 13)
// GET /api/sos/helplines?category=police&state=Maharashtra
// =====================================================
router.get('/helplines', async (req, res) => {
  try {
    const { category, state } = req.query;

    let query = supabase
      .from('helplines')
      .select('*')
      .eq('is_active', true)
      .order('priority_order', { ascending: true });

    if (category) query = query.eq('category', category);
    if (state) query = query.or(`state.eq.${state},state.is.null`);

    const { data, error } = await query;
    if (error) throw error;

    return res.status(200).json({ success: true, data: { helplines: data } });

  } catch (error) {
    console.error('Helplines error:', error);
    return res.status(500).json({ success: false, error: 'Failed to get helplines' });
  }
});

// =====================================================
// ROUTE: NEARBY SAFETY RESOURCES (Module 15)
// GET /api/sos/nearby?lat=19.07&lng=72.87&radius=5000&type=hospital
// =====================================================
router.get('/nearby', async (req, res) => {
  try {
    const { lat, lng, radius = 5000, type } = req.query;

    if (!lat || !lng) {
      return res.status(400).json({ success: false, error: 'lat and lng are required' });
    }

    // Simple bounding box filter (approx 1 degree lat/lng â‰ˆ 111km)
    const radiusDeg = (Number(radius) / 1000) / 111;
    const minLat = Number(lat) - radiusDeg;
    const maxLat = Number(lat) + radiusDeg;
    const minLng = Number(lng) - radiusDeg;
    const maxLng = Number(lng) + radiusDeg;

    let query = supabase
      .from('safety_resources')
      .select('*')
      .eq('is_active', true)
      .gte('latitude', minLat).lte('latitude', maxLat)
      .gte('longitude', minLng).lte('longitude', maxLng);

    if (type) query = query.eq('resource_type', type);

    const { data, error } = await query;
    if (error) throw error;

    // Sort by distance (Haversine approx)
    const withDistance = (data || []).map(r => {
      const dLat = (r.latitude - lat) * Math.PI / 180;
      const dLng = (r.longitude - lng) * Math.PI / 180;
      const a = Math.sin(dLat/2)**2 + Math.cos(lat*Math.PI/180) * Math.cos(r.latitude*Math.PI/180) * Math.sin(dLng/2)**2;
      const dist = 6371000 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return { ...r, distance_meters: Math.round(dist) };
    }).sort((a, b) => a.distance_meters - b.distance_meters);

    return res.status(200).json({ success: true, data: { resources: withDistance } });

  } catch (error) {
    console.error('Nearby resources error:', error);
    return res.status(500).json({ success: false, error: 'Failed to get nearby resources' });
  }
});

// =====================================================
// HELPER: Notify emergency contacts (Module 26)
// Logs notification records â€” integrate Twilio/email later
// =====================================================
async function notifyEmergencyContacts(userId, incident, message, address) {
  try {
    // Get active emergency contacts
    const { data: contacts } = await supabase
      .from('emergency_contacts')
      .select('*')
      .eq('user_id', userId)
      .eq('is_active', true)
      .order('priority', { ascending: true });

    if (!contacts || contacts.length === 0) return;

    const notificationRecords = [];

    for (const contact of contacts) {
      // Decrypt phone number
      let phone = null;
      try {
        const { decrypt: dec } = require('../middleware/encryption');
        phone = dec(contact.phone_number_encrypted, contact.phone_number_iv, contact.phone_number_auth_tag);
      } catch (e) {
        console.error('Decrypt phone error:', e);
      }

      notificationRecords.push({
        incident_id: incident.id,
        user_id: userId,
        recipient_type: 'emergency_contact',
        recipient_id: contact.id,
        recipient_phone: phone,
        recipient_email: contact.email || null,
        notification_type: 'sms',
        channel: 'twilio', // placeholder
        message,
        status: 'pending',
      });
    }

    if (notificationRecords.length > 0) {
      await supabase.from('notifications').insert(notificationRecords);
      // Mark contacts as notified on incident
      await supabase.from('sos_incidents').update({ contacts_notified: true }).eq('id', incident.id);
    }

    // TODO: Integrate Twilio/WhatsApp here for actual sending
    // For each record, call sendSMS(record.recipient_phone, record.message)

  } catch (err) {
    console.error('notifyEmergencyContacts error:', err);
  }
}

module.exports = router;